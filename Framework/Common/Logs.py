'''
Support for log files, including generic messages.
Simplified from X3_Customizer, dropping support for file renaming
and hash comparisons, since all generated files should be safely
in their own extension folder.
'''
from ..Documentation import Doc_Category_Default
_doc_category = Doc_Category_Default('Common')

import os
from pathlib import Path
import json
from ..Common.Settings import Settings
from ..Common import Change_Log


class Plugin_Log_class:
    '''
    Container for logs generated by plugins.

    Attributes:
    * log_file
      - File object for the log, opened on the first write.
    * logging_function
      - Optional function which will be called by Print instead
        of doing the normal file write. The function should accept
        one argument, the message string.
    '''
    def __init__(self):
        self.log_file = None
        self.logging_function = None

    def Print(self, line):
        '''
        Write a line to the summary file.
        '''
        line = str(line)
        # If there is a logging_function attached, call it.
        if self.logging_function != None:
            self.logging_function(line)
            return

        # Open the file if needed.
        if self.log_file == None:
            self.log_file = open(Settings.Get_Plugin_Log_Path(), 'w')
        self.log_file.write(line + '\n')
        # Flush out to be a little safer against crashes.
        self.log_file.flush()
        return

    def Close(self):
        'Close the log file safely; the next Print will overwrite it.'
        if self.log_file != None:
            self.log_file.close()
        self.log_file = None
        return

# Static log object.
Plugin_Log = Plugin_Log_class()
    
# TODO: protection against files being edited externally, notably
# for content.xml files (most others are probably fine).
class Customizer_Log_class:
    '''
    Container for logged information from the customizer framework,
    from a prior run or to be saved at the end of the current run.
    Separate logs should be used for each.

    Attributes:
    * version
      - String, version of the customizer.
    * file_paths_written
      - List of relative paths of files written out by the customizer.
      - Relative to the output extension folder.
      - When from an older run, these files should be removed or overwritten
        by the newer run.
    '''
    def __init__(self):
        # Always default to the current highest version.
        # When loading an older log, it can overwrite this.
        self.version = Change_Log.Get_Version()
        self.file_paths_written = []


    def Load(self, log_path):
        '''
        Load information from an existing log json file.
        Clears any existing information.
        If a log file is not found, nothing will be changed.
        '''
        # Version can be left as whatever, but need to clear the
        # file log.
        self.file_paths_written.clear()

        # If the file doesn't exist, return early.
        if not log_path.exists():
            return

        # Do a json load. Put in try/except for safety.
        try:
            with open(log_path, 'r') as file:
                log_dict = json.load(file)

            # Copy over fields.
            # TODO: think about how to safely do this if new fields are
            # added across version changes, and the old log is from the
            # prior version. Maybe use .get with defaults.
            self.version = log_dict['version']
            for relative_path in log_dict['file_paths_written']:
                self.file_paths_written.append(Path(relative_path))
        except Exception:
            # When something goes wrong, just leave it alone for now.
            pass
        return


    def Store(self):
        '''
        Store the current log information to a log json file.
        Overwrites any prior file.
        '''
        # Store fields into a dict for json to understand.
        log_dict = {}
        log_dict['version'] = self.version
        # Swap all paths to strings (since Paths don't have json support).
        log_dict['file_paths_written'] = [str(x) for x in self.file_paths_written]
        
        # Write the json, with indents for readability.
        with open(Settings.Get_Customizer_Log_Path(), 'w') as file:
            json.dump(log_dict, file, indent = 2)

        return
       

    def Record_File_Path_Written(self, path):
        '''
        Record the path of a file written by the customizer.
        '''
        # Convert to relative path and store.
        # Note: this might have to path upwards, which pathlib can't handle,
        #  so use os relpath.
        relpath = os.path.relpath(path, Settings.Get_Output_Folder())
        self.file_paths_written.append(path)
        return


    def Get_File_Paths_From_Last_Run(self):
        '''
        Returns a list of paths to files which were written on the
        last run.
        '''
        return self.file_paths_written

